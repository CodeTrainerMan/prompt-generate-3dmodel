import { GoogleGenAI, Type } from "@google/genai";
import { SceneConfig, ShapeType } from "../types";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const SYSTEM_INSTRUCTION = `
You are an expert 3D Geometric Modeler and Computer Vision Specialist.
Your task is to analyze a 2D reference image and user prompt to reconstruct a cohesive 3D object using basic geometric primitives (Constructive Solid Geometry).

### CRITICAL SPATIAL & ALIGNMENT RULES:
1. **Global Origin (0,0,0)**: The visual center of mass of the main object MUST be centered at (0, 0, 0).
2. **Ground Plane (Y=0)**: The object must rest on the ground. The lowest shapes should have their bottom faces at Y=0.
3. **Axis Definition**:
   - **Y Axis**: Vertical (Up/Down).
   - **X Axis**: Lateral (Left/Right). Use this for symmetry.
   - **Z Axis**: Depth (Forward/Backward).
4. **Symmetry**: If the object is a creature, vehicle, or robot, you MUST enforce symmetry across the X-axis. 
   - Example: If a left arm is at x=-2, the right arm MUST be at x=2 with mirrored rotation.
5. **Connectivity**: All shapes must physically intersect or touch. 
   - **DO NOT** create floating parts. 
   - A head must overlap with the neck/body. 
   - Wheels must overlap with the chassis.
6. **Bounding Box**: constrain the entire object to fit roughly within a 10x10x10 unit volume.

### SHAPE STRATEGY:
- Use **BOX** for mechanical bodies, chassis, buildings.
- Use **CYLINDER** for limbs, wheels, trunks, pillars.
- Use **SPHERE** for heads, joints, organic blobs.
- Use **CONE** for spikes, trees, noses.
- Use **SCALE** to deform shapes (e.g., a flattened sphere for a turtle shell).

### OUTPUT:
Return ONLY valid JSON.
`;

export const generateReferenceImage = async (prompt: string): Promise<string> => {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash-image",
      contents: {
        parts: [{ text: prompt }]
      }
    });

    if (response.candidates && response.candidates[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData && part.inlineData.data) {
          return part.inlineData.data;
        }
      }
    }
    
    throw new Error("No image generated by the model.");
  } catch (error) {
    console.error("Gemini Image Gen Error:", error);
    throw error;
  }
};

const cleanAndParseJSON = (text: string): any => {
  try {
    // 1. Try direct parse
    return JSON.parse(text);
  } catch (e) {
    // 2. Try stripping markdown code blocks
    const markdownRegex = /```(?:json)?\s*([\s\S]*?)\s*```/;
    const match = text.match(markdownRegex);
    if (match && match[1]) {
      try {
        return JSON.parse(match[1]);
      } catch (e2) {
        throw new Error("Failed to parse JSON from markdown block");
      }
    }
    throw e;
  }
};

export const generateSceneFromPrompt = async (prompt: string, referenceImageBase64?: string): Promise<SceneConfig> => {
  try {
    const parts: any[] = [];
    
    if (referenceImageBase64) {
      parts.push({
        inlineData: {
          mimeType: "image/png",
          data: referenceImageBase64
        }
      });
      parts.push({
        text: `Reconstruct the single primary object shown in this image as a 3D model.
        
        Analysis Steps:
        1. Identify the main subject (e.g., "A red car", "A blue robot").
        2. Determine its main body/chassis and place it at the center (0, Y, 0).
        3. Attach other parts relative to this main body.
        4. User Description: "${prompt}"
        
        ENSURE all parts are connected and centered. No floating parts far from the center.`
      });
    } else {
      parts.push({ text: prompt });
    }

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: { parts },
      config: {
        systemInstruction: SYSTEM_INSTRUCTION,
        // Increase token limit and enable thinking to allow the model to calculate coordinates accurately
        maxOutputTokens: 8192, 
        thinkingConfig: { thinkingBudget: 2048 },
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            backgroundColor: { type: Type.STRING, description: "Hex color code for the scene background" },
            ambientLightColor: { type: Type.STRING, description: "Hex color code for ambient light" },
            ambientLightIntensity: { type: Type.NUMBER, description: "Intensity of ambient light (0.1 - 1.0)" },
            shapes: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  id: { type: Type.STRING, description: "Unique identifier" },
                  type: { type: Type.STRING, enum: Object.values(ShapeType) },
                  position: { type: Type.ARRAY, items: { type: Type.NUMBER }, minItems: 3, maxItems: 3, description: "x, y, z coordinates. Center at 0,0,0" },
                  rotation: { type: Type.ARRAY, items: { type: Type.NUMBER }, minItems: 3, maxItems: 3, description: "Euler angles in radians" },
                  scale: { type: Type.ARRAY, items: { type: Type.NUMBER }, minItems: 3, maxItems: 3, description: "Scale factors x, y, z" },
                  color: { type: Type.STRING, description: "Hex color code" },
                  metalness: { type: Type.NUMBER },
                  roughness: { type: Type.NUMBER },
                  opacity: { type: Type.NUMBER }
                },
                required: ["id", "type", "position", "rotation", "scale", "color"]
              }
            }
          },
          required: ["backgroundColor", "shapes"]
        }
      }
    });

    if (!response.text) {
      throw new Error("No data returned from Gemini");
    }

    // Robust parsing to handle potential thinking-trace artifacts or markdown formatting
    const data = cleanAndParseJSON(response.text) as SceneConfig;
    return data;

  } catch (error) {
    console.error("Gemini 3D API Error:", error);
    throw error;
  }
};